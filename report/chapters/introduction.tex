\chapter{Goal/Objectives}
\label{ch:goal} % This how you label a chapter and the key (e.g., ch:into) will be used to refer this chapter ``Introduction'' later in the report. 
% the key ``ch:into'' can be used with command \ref{ch:intor} to refere this Chapter.
\section{Goals of this project:}
\begin{itemize}
    \item Implement a multi-agent system that includes different levels of intelligence for a card-playing bot.
    \item Define and implement autonomous behaviors for the bots, allowing them to make strategic decisions based on the context of the game.
    \begin{itemize}
        \item Casual player
        \item Make an HiLo strategic agent.
    \end{itemize}
    \item Transpose agent decision on a GUI that shows a visual table and cards.
    \item Measure the winning rate of the agents.
\end{itemize}

\section{Usage scenarios}

Smart 21 will be a full simulation of the real game. Users can decide to play 21 for fun or test the ability of the agents by letting them play and analyze their stategies.  

\section{Definition of done}

Final delivery will be a gradle project that has different running options:

\begin{itemize}
    \item 1. Pure 21 game.
    \item 2. Dumb agent that plays with BDI defined by common sense.
    \item 3. HiLo agent that expoilts HiLO algorithm to count cards and decide autonomously how much money bet on a hand.
\end{itemize}

To test the agents implementation will be measured the amount of money won and risked and compared this data in a grafical representation.

\chapter{Background and link to the theory}

(To be written at the end)
• Relevant architectural styles (the ones mentioned in Section 3)
• Relevant interaction patterns (the ones mentioned in Section 3)
• Relevant software frameworks (the ones mentioned in Sections 3 and 4)


\chapter{Requirements Analysis}

\section{Implicit Requirements}
\begin{itemize}
   \item Software must adhere to the rules of 21, so it must be capable of know who wins the hand and give the right amount of money to the winner.
   \item Users must be capable of following the game flow so the agents need to implement a slowdown mechanism and maybe a clear log.
\end{itemize}

\chapter{Design}

This system is a multi-purpose, it can be used as a classical game to occupy time by a user or can be played by intelligent agent to instruct the user with some basic stategy of the game. \textbf{MAS (Multi-agent-system)} architecture is used here to coordinate the activities of the agents that are players and the dealer. A good abstraction used is the one that compares the Environment typically used in MAS with the table game where agents, based on their intentions and belief react according to changes like: 
\begin{itemize}
    \item Place the cards.
    \item Stand.
    \item Bet.
    \item Raise the bet.
    \item Every entity involved in the action can perfectly see the (virtual) table with cards and money on
 \end{itemize}

The interaction between agents is controlled by \textbf{BlackJackEnvironment} that encapsulates a gameTable object that contains most of the business logic of the game. This system includes also a user graphical interface for monitoring the developement of the game.

\section{Structure (domain entities)}
The entities involved are typically the players and the dealer.




Which entities need to by modelled to reflect the domain? UML class diagram here with
domain entities and possibly messages being exchanged

\section{Interaction}
How should entities interact with each others? UML activity / sequence diagram and
protocols definitions.

\section{Behaviour}
How should each entity behave? UML State diagram.

\section{Architecture}
How are software pieces organised into software modules? UML component / package /
deployment diagrams, data-flow among components, web API description.


\chapter{Salient implementation details}
Anything potentially interesting / non-trivial and technologies adopted to match the
design. This section is expected to be short in case some documentation (e.g. Javadoc
or Swagger Spec) has been produced for the software artefacts. This this case, the
produced documentation should be referenced here.

\chapter{Validation}
Choose a criterion for the evaluation of the produced software and its compliance
to the requirements above. Description of automated (and manual) tests and their
rationale. In case of a test-driven development, describe tests here and possibly report
the amount of passing tests, the total amount of tests and, possibly, the test coverage.

\chapter{Deployment Instructions}
Explain here how to install and launch the produced software artefacts. Assume the
software must be installed on a totally virgin environment. So, report any configuration
step. Gradle and Docker may be useful here to ensure the deployment and launch
processes to be easy.

\chapter{Usage Examples}
Show how to use the produced software artefacts. Ideally, there should be at least one
example for each scenario proposed above.
\chapter{Conclusions}
Recap what you did.